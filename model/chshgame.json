{"init":"// Spin in computational basis\nthis.spinup = '00001111';\nthis.spindown = '11110000';\n\n// Helper functions for binary vector rotation and Hamming distance metric\nthis.rot = (s,n) => { return s.slice(-n % s.length) + s.slice(0,-n % s.length); }\nthis.dhamm = (s,t) => { return [...s].reduce( (a,b,i) => a + (b === t.charAt(i) ? 0 : 1),0 ) }\n\n// Start the first round\nthis.log('--- SIMULATION STARTS ---');\n\n// Run all possible question pairs\nreturn [ \"Start-Q+0+0\", \"ZStart-Q+0+1\", \"ZZStart-Q+1+0\", \"ZZZStart-Q+1+1\"];","oper":"// Location is the first part of the state and the same within the clique\n// Subsequent parts of the state contain the messages and memories\nconst location = c[0].split(\"-\")[0];\nconst messages = {};\nc.forEach( x => {\n  const m = x.split('-')[1];\n  if ( m ) {\n    const p = m.split('+');\n    messages[p[0]] = (p.length > 2 ? p.slice(1) : p[1]);\n  }\n});\n\n// Classical state machine\nconst ops = [];\nif ( location === 'Start' ) {\n  \n  // Send classical messages, one for Alice, one for Bob\n  const [ QA, QB ] = messages[\"Q\"];\n  ops.push( [ \"AliceQ-Question+\" + QA, \"BobQ-Question+\" + QB, \"Particle\" ] );\n  \n} else if ( location === 'Particle' ) {\n\n  // Send entangled spin particles to Alice and Bob\n  // Here particle is a superposition of all binary rotations\n  for( let i=0; i<this.spinup.length; i++ ) {\n    ops.push( [\n      'AliceSG-Particle+' + this.rot(this.spinup,i),\n      'BobSG-Particle+' + this.rot(this.spindown,i)\n    ]);\n  }\n  \n} else if ( location === 'AliceQ' ) {\n\n  // Parse message and set measurement angle:\n  // - If question is 0, do not rotate\n  // - If question is 1, rotate -45° (-2*pi/8)\n  const question = messages[\"Question\"];\n  const rotate = ( question === '0' ? 0 : Math.round( (-2/8) * this.spinup.length) );\n  const setting = this.rot(this.spinup, rotate);\n  ops.push( [ 'AliceSG-Measure+' + question + '+' + setting ] );\n  \n} else if ( location === 'AliceSG' ) {\n\n  // Parse message\n  const [question,setting] = messages[\"Measure\"];\n  const particle = messages[\"Particle\"];\n\n  // Simulate Stern–Gerlach\n  // You as an observer can only detect up/down, which\n  // respond to responses 0/1\n  const d = this.dhamm(particle,setting);\n  const limit = Math.round(this.spinup.length / 2);\n  const R0 = 'Responses-Alice+' + question + '+' + '0';\n  const R1 = 'Responses-Alice+' + question + '+' + '1';\n  if ( d > limit ) ops.push( [ R1, R1 ] );\n  if ( d == limit ) ops.push( [ R0 ], [ R1 ] );\n  if ( d < limit ) ops.push( [ R0, R0 ] );\n  \n} else if ( location === 'BobQ' ) {\n\n  // Parse message and set measurement angle:\n  // - If question is 0, rotate 135° (3*pi/8)\n  // - If question is 1, rotate -135° (-3*pi/8)\n  const question = messages[\"Question\"];\n  const rotate = ( question === '0' ? Math.round( (3/8) * this.spinup.length) : Math.round( (-3/8) * this.spinup.length) );\n  const setting = this.rot(this.spinup, rotate);\n  ops.push( [ 'BobSG-Measure+' + question + '+' + setting ] );\n  \n} else if ( location === 'BobSG' ) {\n\n  // Parse message\n  const [question,setting] = messages[\"Measure\"];\n  const particle = messages[\"Particle\"];\n\n  // Simulate Stern–Gerlach\n  // You as an observer can only detect up/down, which\n  // respond to responses 0/1\n  const d = this.dhamm(particle,setting);\n  const limit = Math.round(this.spinup.length / 2);\n  const R0 = 'Responses-Bob+' + question + '+' + '0';\n  const R1 = 'Responses-Bob+' + question + '+' + '1';\n  if ( d > limit ) ops.push( [ R1, R1 ] );\n  if ( d == limit ) ops.push( [ R0 ], [ R1 ] );\n  if ( d < limit ) ops.push( [ R0, R0 ] );\n  \n} else if ( location.startsWith('Z') ) {\n  // Delayed state\n  ops.push( c.map( x => x.substring(1) ) );\n}\n\nreturn ops;","coord":"// Coordinate is the first part of the state\nreturn s.split('-')[0];","probs":"// Calculate probabilities\nconst ps = this.probsPerm(cs);\n\nif ( coord === 'Responses' ) {\n\n  // Possible responses\n  const prs = { '0⊕0': 0, '0⊕1': 0, '1⊕0': 0, '1⊕1': 0 }; \n  let label = '';\n  cs.forEach( (c,i) => {\n    // Extract messages\n    const messages = {};\n    c.forEach( x => {\n      const m = x.state.split('-')[1];\n      if ( m ) {\n        const p = m.split('+');\n        messages[p[0]] = (p.length > 2 ? p.slice(1) : p[1]);\n      }\n    });\n\n    // Questions and responses\n    if ( messages[\"Alice\"] && messages[\"Bob\"] ) {\n      const [QA,RA] = messages[\"Alice\"];\n      const [QB,RB] = messages[\"Bob\"];\n      if ( !label ) {\n        label = QA+'∧'+QB+' = ';\n      }\n\n      prs[RA+'⊕'+RB] += ps[i];\n    }\n  });\n\n  // Print the result\n  const es = [];\n  for( let [k,v] of Object.entries(prs) ) {\n    es.push(k + ' ' + (100*v).toFixed(2) + '%');\n  }\n  this.log(label + es.join(' | '));\n}\n\nreturn ps;","show":"return true;","detectors":"return [];"}
